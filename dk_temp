RAISERROR('	CREATING OR ALTERING PROCEDURE [Auditing].[usp_ReadLogs]',10,1) WITH NOWAIT;
if object_id('Auditing.usp_ReadLogs') is null exec('create procedure [Auditing].[usp_ReadLogs] as select getdate() DT')
GO
  alter procedure Auditing.usp_ReadLogs
	@OPS_ID smallint
WITH ENCRYPTION
as
set nocount on
declare @ASE_ID int,
		@AES_ID tinyint,
		@SessionObjectName nvarchar(128),
		@StoragePath varchar(1000),
		@IsActive bit,
		@LastfileName varchar(1000),
		@LastOffset bigint,
		@ALR_ID int,
		@RowCount int,
		@ErrorMessage nvarchar(2000)

if not exists (select * from Licensing.fn_ValidateLicense()) return

declare cSessions cursor static forward_only for
	select ASE_ID, AUT_Name, Auditing.fn_GetServerAuditingPath(ASE_StoragePath), ASE_IsActive
	from Auditing.AuditSessions
		inner join Auditing.AuditTemplates on AUT_ID = ASE_AUT_ID

open cSessions

fetch next from cSessions into @ASE_ID, @SessionObjectName, @StoragePath, @IsActive
while @@FETCH_STATUS = 0
begin
	exec Auditing.usp_ReadXEData @OPS_ID = @OPS_ID,
									@ASE_ID = @ASE_ID,
									@SessionObjectName = @SessionObjectName,
									@StoragePath = @StoragePath,
									@IsActive = @IsActive

	exec Auditing.usp_ReadServerAuditData @OPS_ID = @OPS_ID,
											@ASE_ID = @ASE_ID,
											@SessionObjectName = @SessionObjectName,
											@StoragePath = @StoragePath,
											@IsActive = @IsActive
				
	fetch next from cSessions into @ASE_ID, @SessionObjectName, @StoragePath, @IsActive
end
close cSessions
deallocate cSessions

GO
