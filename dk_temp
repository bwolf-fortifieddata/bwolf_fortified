RAISERROR('	CREATING OR ALTERING PROCEDURE [dbo].[BackupException_AG]',10,1) WITH NOWAIT;
if object_id('dbo.BackupException_AG') is null exec('create procedure [dbo].[BackupException_AG] as select getdate() DT')
GO  
/*******************************************************************************************************************
Created By: Keith Buck
Created On: 3/20/2018

Purpose: Validate FULL and/or Differential and/or Transaction Log backups for databases in a Availability Group where the 
	backups could be taken by any server on which the AG resides. Report only includes DISK backups that are not corrupted.
	There are no other exclusions or inclusions from the backupset
	THIS REPORT ONLY NEEDS TO BE RUN ON THE PRIMARY REPLICA however you can run it on any or all if you like but you will get
	one email per execution depending on if issues are found.

Parameters:	
	@DebugOverride	BIT = 0 :	Real parameter accepted by Procedure that will override the Debug setting in the table of parameters, makes it easier to debugz

Former Parameters now moved to config_fddba2 Where Name=parameters and Domain =BackupExceptionReport_AG
	@NamesList			:List of Availability Group names and Listeners delimted by tilde then caret. 
							Format is AgName~ListenerName^AgName~ListenerName^AgName~ListenerName
	@InstanceNames		: tilde ~ delimetedlList of Instances in the AG.
	@HoursForFull		: Number of hours to check since a FULL backup was taken. Any database that 
							has not had a backup in the last @HoursForFull will show up in this report.
	@MinutesForDiff		: Number of hours to check since a DIFFERENTIAL backup was taken. If 0 then DIFF backups will not be checked.
	@MinutesForTranLog	: Number or minutes to check since a Log backup was taken. If 0 then TRANLOG backups will not be checked.
	@emailRecipients	: Semi-colon delimted list of email account that receive the report
	@EmailSubject		: Text for the subject, procedure will replace explict text '[SERVERNAME]' with the actual server name
	@EmailProfile		: Database Mail profile to use to send emails
	@H3Text				:Text for the H3 (heading 3) section of the report. this is where we can include a message 
							specific to Agio or not. Agio would be used for prod. DO NOT inlcude the <H3> HTML tags
	@OnCleanRecipients	: Semi-colon delimted list of email account that receive an email that no exceptions were found. If blank or NULL no email will be sent.
	@AuthAccount		: If not using windows authentication for OPENROWSET command then enter a SQL Account name, if NULL windows auth is used see post sections for permissions
	@AuthPwd			: Password to be used if @AuthAccount is not null.
	@WriteToErrorLog	: Bit flag indicationg to write certain output statements to the SQL Error Log with a severity of 16 if missing backups are found.
	@DeviceType			:caret ^ delimted string of backup device types (tinyint) from table backupmediafamily default 2, NOT NULL  https://technet.microsoft.com/en-us/library/ms190284(v=sql.110).aspx
							2 = Disk, 5 = Tape, 7 = Virtual device, 105 = A permanent backup device.
	@Debug				: Flag to use for debugging to show output of steps. 1 = on, 0 = off

If using a non sysadmin account for this check it will need to have the following permissions
		GRANT SELECT ON [dbo].[backupset] TO [AccountName] AS [dbo]
		GRANT SELECT ON [dbo].[backupmediafamily] TO [DBA_Backup_Reader] AS [dbo]
		GRANT VIEW ANY DEFINITION TO [DBA_Backup_Reader]
		GRANT VIEW ANY DATABASE TO [DBA_Backup_Reader]
		GRANT VIEW SERVER STATE TO [DBA_Backup_Reader]


Changes:
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Date:	12/26/2019	
By:		Keith Buck
Note:	Added @DebugOverride parameter. Updated comments header and changed parameter delimters for	@NamesList and @InstanceNames list as the move to have them all in one entry in a table 
		causes a parsing issue
3/13/2019 Keith Buck - Fixed bugs where report was not accurate at all, added more columns to report to match exlusion table, added date report run to Param List in report
6/6/2019 Keith BUck - Fixed bug, email profile was hard coded, change to accept paramter @EmailProfile.
12/4/2019 Keith Buck - Fixed bug from 6/6 again, not sure what happened here. Add in parameter for device type
3/18/2020 Keith Buck - change parameter @DBList from size 2048 to MAX as it will conver the @sql down from MAX to 2048 and fail on a server with a lot of databases in the AG
2020-04-20 Wolf - minor alteration to obtain AG info and default mail profile from instance configuration

BackupException_AG 1
*******************************************************************************************************************/
ALTER PROCEDURE dbo.BackupException_AG(
	@DebugOverride	BIT = 0
)
WITH ENCRYPTION
AS
SET NOCOUNT ON
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED


/***************************************************************************************************
** <GET ALL THE PARAMETERS FROM THE TABLE>
***************************************************************************************************/
declare @parameters             varchar(3950)   ,
        @name                   varchar(3950)   ,
        @value                  varchar(3950)   ,
        @NamesList              varchar(1028)   ,
        @InstanceNames          varchar(1028)   ,
        @HoursForFull           int             ,
        @MinutesForDiff         int             ,
        @MinutesForTranLog      int             ,
        @EmailRecipients        varchar(1000)   ,
        @EmailSubject           varchar(256)    ,
        @EmailProfile           sysname         ,
        @H3Text                 varchar(200)    ,
        @OnCleanRecipients      varchar(1000)   ,
        @AuthAccount            varchar(128)    ,
        @AuthPwd                varchar(256)    ,
        @WriteToErrorLog        bit             ,
        @Debug                  bit             ,
        @DeviceType             varchar(50)	



SELECT TOP 1 @parameters = [value] FROM FDDBA.dbo.config_fddba2 WHERE [name] = 'parameters' and [domain] = 'BackupExceptionReport_AG'

DECLARE param_cur CURSOR FAST_FORWARD LOCAL FOR
SELECT a, b FROM FDDBA.dbo.fSplit2columns(@parameters, '=', ',')
OPEN param_cur
FETCH NEXT FROM param_cur INTO @name, @value
WHILE @@FETCH_STATUS != -1
BEGIN
		SET @name = LTRIM(RTRIM(@name))
		SET @value = LTRIM(RTRIM(@value))
		IF @name = 'NamesList' 
			SET @NamesList = ISNULL(@value,'') 

		IF @name = 'InstanceNames' 
			SET @InstanceNames = ISNULL(@value,'')
		
		IF @name = 'HoursForFull' 
			SET @HoursForFull = CAST(ISNULL(@value,'0') AS INT)

		IF @name = 'MinutesForDiff' 
			SET @MinutesForDiff = CAST(ISNULL(@value,'0') AS INT)
			
		IF @name = 'MinutesForTranLog' 
			SET @MinutesForTranLog = CAST(ISNULL(@value,'0') AS INT)
		
		IF @name = 'emailRecipients'
			SET @EmailRecipients = @value

		IF @name = 'H3Text'
			SET @H3Text = @value

		IF @name = 'OnCleanRecipients'
			SET @OnCleanRecipients = @value
			
		IF @name = 'AuthAccount'
		BEGIN
			IF LEN( ISNULL(@value,'')) > 0
				SET @AuthAccount= @value
		END

		IF @name = 'AuthPwd'
		BEGIN
			IF LEN( ISNULL(@value,'')) > 0
				SET @AuthPwd= @value
		END

		IF @name = 'EmailSubject'
			SET @EmailSubject = @value

		IF @name = 'EmailProfile'
			SET @EmailProfile = @value

		IF @name = 'WriteToErrorLog'
			SET @WriteToErrorLog = CAST(ISNULL(@value,'0') AS BIT)

		
		IF @name = 'DeviceType'
			SET @DeviceType = @value

		IF @name = 'Debug'
		BEGIN
			IF @value IS NULL
				SET @Debug = 0
			ELSE
				SET @Debug = CAST(SUBSTRING(LTRIM(RTRIM(@value)),1,1) AS BIT)
		END
		FETCH NEXT FROM param_cur INTO @name, @value
END
CLOSE param_cur
DEALLOCATE param_cur
IF @DebugOverride = 1 
	SET  @Debug = @DebugOverride

/***************************************************************************************************
** </ GET ALL THE PARAMETERS FROM THE TABLE>
***************************************************************************************************/

/***************************************************************************************************
** grab defaults from system rather than fddba config
***************************************************************************************************/
        if      @name is not null
                begin
                        --availability group replicas
                        select  @InstanceNames  = null

                        select  @InstanceNames  = coalesce(@InstanceNames + '~', '') + n.replica_server_name
                        from    sys.dm_hadr_availability_replica_cluster_nodes n                        

                        --availability groups
                        set     @namesList      = null

                        select  @NamesList      = coalesce(@NamesList + '^', '') + ag.name + '~' + isnull(agl.dns_name, 'No_Listener')
                        from    sys.availability_groups ag
                                left join sys.availability_group_listeners agl on ag.group_id = agl.group_id

                        --default mail profile
                        select  @EmailProfile   = null

                        select  @EmailProfile   = sp.name
                        from    msdb.dbo.sysmail_principalprofile pp
                                inner join msdb.dbo.sysmail_profile sp on pp.profile_id = sp.profile_id
                        where   pp.is_default = 1
                end

/***************************************************************************************************
**
***************************************************************************************************/



--device type may not be in the config table, if not just default it to 2 (Disk)
IF @DeviceType IS NULL
	Set @DeviceType = '2'
ELSE
BEGIN 
	-- DEVICE TYPE IS PASSED IN AS A caret^ delmited string, we need to change it to comma delmited to use in an "IN clause
	set @DeviceType = REPLACE(@DeviceType,'^',',')
END 

IF @Debug = 1
BEGIN
	PRINT '@NamesList = ' + @NamesList
	PRINT '@InstanceNames = ' + @InstanceNames
	PRINT '@HoursForFull = ' + CAST(@HoursForFull AS VARCHAR(100))
	PRINT '@MinutesForDiff = ' + CAST(@MinutesForDiff AS VARCHAR(100))
	PRINT '@MinutesForTranLog = ' + CAST(@MinutesForTranLog AS VARCHAR(100))
	PRINT '@EmailRecipients = ' + @EmailRecipients
	PRINT '@H3Text = ' + @H3Text 
	PRINT '@OnCleanRecipients = ' +@OnCleanRecipients 
	PRINT '@EmailSubject = ' + @EmailSubject
	PRINT '@EmailProfile = ' + @EmailProfile
	PRINT '@WriteToErrorLog = ' + CAST(@WriteToErrorLog AS VARCHAR(100))
	PRINT '@AuthAccount = ' + ISNULL(@AuthAccount,'NULL')
	PRINT '@AuthPwd = ' + ISNULL(@AuthPwd,'NULL')
	PRINT '@DeviceType = ' + ISNULL(@DeviceType,'NULL')
END


DECLARE @AgName						VARCHAR(1028) 
DECLARE @ListenerName				VARCHAR(128)
DECLARE @sql						NVARCHAR(MAX)
DECLARE @DBList						NVARCHAR(MAX)
DECLARE @msg						NVARCHAR(2048)
DECLARE @ServerName					SYSNAME
DECLARE @DbName						SYSNAME
DECLARE @dt							DATETIME
DECLARE @ReportDate					VARCHAR(30)

DECLARE @Body						NVARCHAR(MAX)    
DECLARE @Xml						NVARCHAR(MAX)
DECLARE @HtmlExclusions				NVARCHAR(MAX)
DECLARE @HtmlParams					NVARCHAR(MAX)



--set job times to negative if a positve number was passed in
IF @HoursForFull > 0
	SET @HoursForFull = @HoursForFull * -1
--diff
IF @MinutesForDiff != 0  
BEGIN
	IF @MinutesForDiff > 0 
		SET @MinutesForDiff = @MinutesForDiff * -1
END
--log
IF @MinutesForTranLog != 0  
BEGIN
	IF @MinutesForTranLog > 0 
		SET @MinutesForTranLog = @MinutesForTranLog * -1
END

IF @EmailSubject IS NOT NULL
BEGIN
	SET @EmailSubject = REPLACE(@EmailSubject,'[SERVERNAME]',@@SERVERNAME)
END

IF @H3Text IS NOT NULL
BEGIN
	SET @H3Text = REPLACE(@H3Text,'[SERVERNAME]',@@SERVERNAME)
END


/************************************************************************
	Break down the @AgList passed in values to a table of Availability
	Grop names and listners
************************************************************************/

IF @NamesList IS NOT NULL
BEGIN
	DECLARE @agtemp						TABLE(AgList VARCHAR(1028))
	INSERT INTO @agtemp (AgList) SELECT items FROM dbo.fSplit(@NamesList, '^')

	IF @Debug = 1
	BEGIN
		select '@agtemp' as TempTableName, * from @agtemp
	END

	IF OBJECT_ID('tempdb..#AGS') IS NOT NULL
		DROP TABLE #AGS
	CREATE TABLE #AGS(AG VARCHAR(1028) NULL, Listener VARCHAR(1028) NULL)


	while   (select count(*) from @agtemp) >0
	        begin
                        set     @agname = null
                        select  top 1 @agname = aglist
                        from    @agtemp


                        insert  into #ags (ag, listener)
                        select  substring(@agname,1,charindex('~',@agname)-1) , substring(@agname,charindex('~',@agname)+1,len(@agname))


                        delete  from @agtemp
                        where	aglist = @agname  
	        end

	IF      @Debug = 1
	        BEGIN
		        SELECT '#AGS' as TempTableName, * from #AGS
	        END

END
/*********************************************************************************
	Connect to each listener and obtain a list of databases within each AG
*********************************************************************************/
IF OBJECT_ID('tempdb..#ListenerDBs') IS NOT NULL
	DROP TABLE #ListenerDBs
CREATE TABLE #ListenerDBs(AGName VARCHAR(1028), DatabaseName SYSNAME)


SET @AgName = NULL
SET @ListenerName = NULL
DECLARE curAgs  CURSOR  FAST_FORWARD LOCAL FOR 
	SELECT AG, Listener  FROM #AGS
OPEN curAgs
FETCH NEXT FROM curAgs INTO @AgName, @ListenerName
WHILE @@FETCH_STATUS = 0
BEGIN
	
	SET @sql = N'INSERT INTO #ListenerDBs(AGName, DatabaseName)
	SELECT ''' + @AgName + ''', a.DatabaseName FROM OPENROWSET(''SQLNCLI11'', ''Server=' +  @ListenerName +   
		CASE WHEN @AuthAccount IS NULL THEN 
			N';Trusted_Connection=Yes;Integrated Security=SSPI' + N';''' 
			ELSE 	
			N';UID=' + @AuthAccount + N';PWD=' + @AuthPwd + N';''' 
			END 
		+ N',
			''SELECT 
				d.name AS DatabaseName
				FROM
				sys.databases d
				INNER JOIN sys.dm_hadr_database_replica_states drs on d.group_database_id = drs.group_database_id AND d.replica_id = drs.replica_id
				INNER JOIN sys.availability_groups ag on drs.group_id = ag.group_id
			WHERE 
				d.replica_id IS NOT NULL
				AND ag.name= N''''' + @AgName  + N'''''
			ORDER BY
				ag.name,
				d.name'') AS a'
	IF @Debug = 1
	BEGIN
		SELECT @sql AS CursorLoop_SQL_Statement
	END
	EXECUTE sp_executesql @sql
	FETCH NEXT FROM curAgs INTO @AgName, @ListenerName
END
CLOSE curAgs
DEALLOCATE curAgs



IF @Debug =1
BEGIN
	SELECT '#ListenerDBs' as 'TempTableName', * FROM #ListenerDBs -- ORDER BY AGName, DatabaseName
END


select @DBList= CAST( stuff( (select ',' +  '''' + DatabaseName + ''''
				FROM #ListenerDBs
				for xml path('')), 1, 1, '') AS NVARCHAR(MAX))

IF @Debug = 1
SELECT @DBList as '@DBList'

/*********************************************************************************
	Connect to each server and obtain the latest backup for each database 
*********************************************************************************/
IF OBJECT_ID('tempdb..#BackupInfo') IS NOT NULL
	DROP TABLE #BackupInfo
CREATE TABLE #BackupInfo(ServerName SYSNAME, DatabaseName SYSNAME, BackupType VARCHAR(30), BackupStartDate DATETIME2(3))



DECLARE curBackups  CURSOR  FAST_FORWARD LOCAL FOR 
	SELECT items FROM dbo.fSplit(@InstanceNames,'~')
OPEN curBackups
FETCH NEXT FROM curBackups INTO @ServerName
WHILE @@FETCH_STATUS = 0
BEGIN 
	IF @Debug =1 
	BEGIN
		SET @msg = 'Working on backups for server: ' + @ServerName + '.'
		RAISERROR(@msg,10,1) WITH NOWAIT;
	END
	-- GET THE BACKUPS
	SET @sql = N'INSERT INTO #BackupInfo(ServerName, DatabaseName, BackupType , BackupStartDate)
	SELECT ''' + @ServerName + ''',  a.database_name,  CASE WHEN type = ''D'' THEN ''FULL'' WHEN type = ''L'' THEN ''log'' WHEN type = ''I'' THEN ''DIFF'' ELSE ''UNKNOWN'' END , a.LastBackupStart FROM OPENROWSET(''SQLNCLI11'', ''Server=' +  @ServerName +   
		CASE WHEN @AuthAccount IS NULL THEN 
			N';Trusted_Connection=Yes;Integrated Security=SSPI' +  N';''' 
			ELSE 	
			N';UID=' + @AuthAccount + N';PWD=' + @AuthPwd + N';'''
			END 
		+ N',
					''Select DISTINCT 
								s.database_name,
								s.type,
								MAX(s.BACKUP_START_DATE) AS LastBackupStart
							FROM	
								msdb..backupset s
								INNER JOIN msdb.dbo.backupmediafamily A on S.media_set_id = A.media_set_id
	
							Where
								s.type IN(''''D'''',''''L'''' ,''''I'''' )
								AND S.database_name IN('  + REPLACE(@DBList,'''','''''') +  ')
								AND a.device_type in (' + @DeviceType + ')
								AND s.is_damaged = 0
							GROUP BY
								s.database_name
								,s.type
							'') AS a'
		IF @Debug = 1
		BEGIN
			RAISERROR('',10,1) WITH NOWAIT;
			RAISERROR('sp_ExecuteSQL Statement to get ALL backups.',10,1) WITH NOWAIT;
			RAISERROR(@sql,10,1) WITH NOWAIT;
		END
		EXECUTE sp_executesql @sql 

	
	FETCH NEXT FROM curBackups INTO @ServerName
END
CLOSE curBackups
DEALLOCATE curBackups

--fix to ensure there is an entry for every database for full, diff and tran log, LOOP through all the databases and insert a record if none exists
--this allows us to do inner joins later in the script and eliminates incorrect data
DECLARE curDBs CURSOR  FAST_FORWARD LOCAL FOR
SELECT REPLACE(items,'''','')  FROM DBO.fSplit(@DBList,',')
OPEN curDBs
FETCH NEXT FROM curDBS into @DbName
WHILE @@FETCH_STATUS = 0
BEGIN
	IF NOT EXISTS(SELECT * FROM #BackupInfo WHERE DatabaseName = @DbName AND BackupType = 'FULL')
		INSERT INTO #BackupInfo(ServerName, DatabaseName, BackupType , BackupStartDate) VALUES(N'NONE', @DbName, 'FULL', '1/1/2000')
	IF NOT EXISTS(SELECT * FROM #BackupInfo WHERE DatabaseName = @DbName AND BackupType = 'DIFF')
		INSERT INTO #BackupInfo(ServerName, DatabaseName, BackupType , BackupStartDate) VALUES(N'NONE', @DbName, 'DIFF', '1/1/2000')
	IF NOT EXISTS(SELECT * FROM #BackupInfo WHERE DatabaseName = @DbName AND BackupType = 'LOG')
		INSERT INTO #BackupInfo(ServerName, DatabaseName, BackupType , BackupStartDate) VALUES(N'NONE', @DbName, 'LOG', '1/1/2000')

	FETCH NEXT FROM curDBS into @DbName
END
CLOSE curDBs
DEALLOCATE curDBs


CREATE CLUSTERED INDEX cix_BackupInfo on #BackupInfo (BackupType, DatabaseName, BackupStartDate)

IF @Debug = 1
		BEGIN
			RAISERROR('',10,1) WITH NOWAIT;
			RAISERROR('Populating #BackupInfoLast',10,1) WITH NOWAIT;
		END

IF OBJECT_ID('tempdb..#BackupInfoLast') IS NOT NULL
	DROP TABLE #BackupInfoLast
CREATE TABLE #BackupInfoLast(ServerName SYSNAME, DatabaseName SYSNAME, BackupType VARCHAR(30), BackupStartDate DATETIME2(3))

INSERT INTO #BackupInfoLast(ServerName, DatabaseName, BackupType, BackupStartDate)
SELECT b.ServerName,  b.DatabaseName, b.BackupType , b.BackupStartDate 
	FROM 
	#BackupInfo b
	INNER JOIN (SELECT DatabaseName, MAX(BackupStartDate) AS BackupStartDate, BackupType FROM #BackupInfo GROUP BY DatabaseName, BackupType) as x 
		ON b.DatabaseName COLLATE SQL_Latin1_General_CP1_CI_AS = x.DatabaseName COLLATE SQL_Latin1_General_CP1_CI_AS 
		AND b.BackupStartDate = x.BackupStartDate 
		AND b.BackupType COLLATE SQL_Latin1_General_CP1_CI_AS = x.BackupType COLLATE SQL_Latin1_General_CP1_CI_AS
	--LEFT JOIN dbo.BackupReportExclusion bu on b.DatabaseName = bu.DatabaseName 
--WHERE
--	bu.DatabaseName IS NULL
ORDER BY 
	b.DatabaseName 
	,b.BackupType




IF @Debug = 1
BEGIN
	SELECT '#BackupInfo' as  'TempTable_BackupInfo', * FROM #BackupInfo ORDER BY BackupType, DatabaseName, BackupStartDate
	SELECT 'BackupReportExclusion' as 'Table_BackupReportExclusion', DatabaseName  FROM dbo.BackupReportExclusion 
	SELECT 
		'#BackupInfoLast' as  'TempTable_BackupInfoLast'
		,DatabaseName
		,BackupType 
		,BackupStartDate 
		,CASE WHEN BackupType ='FULL' THEN DATEDIFF(HOUR, BackupStartDate, GETDATE()) ELSE NULL END AS HoursSinceLastBackup
		,CASE WHEN BackupType ='FULL'  THEN @HoursForFull ELSE NULL END AS '@HoursForFull'
		,CASE WHEN BackupType = 'DIFF' AND @MinutesForDiff != 0 THEN DATEDIFF(MINUTE,BackupStartDate,GETDATE()) ELSE NULL END AS MinutesSinceLastBackup
		,CASE WHEN BackupType ='DIFF' AND @MinutesForDiff != 0 THEN @MinutesForDiff  ELSE NULL END AS '@MinutesForDIFF'
		,CASE WHEN BackupType ='LOG' AND @MinutesForTranLog != 0 THEN DATEDIFF(MINUTE, BackupStartDate, GETDATE())  ELSE NULL END AS MinutesSinceLastBackup
		,CASE WHEN BackupType ='LOG' AND @MinutesForTranLog != 0 THEN @MinutesForTranLog  ELSE NULL END AS '@MinutesForTranLog'
		FROM 
		#BackupInfoLast 
	ORDER BY 
		DatabaseName
		,BackupType
END





/*********************************************************************************
	Populate a temp table with all the missing backups DB Name and Type
*********************************************************************************/

IF @Debug = 1
		BEGIN
			RAISERROR('',10,1) WITH NOWAIT;
			RAISERROR('Inserting missing FULL',10,1) WITH NOWAIT;
		END

IF OBJECT_ID('tempdb..#BACKUP_EXCEPTION') IS NOT NULL	
	DROP TABLE #BACKUP_EXCEPTION
CREATE TABLE #BACKUP_EXCEPTION(DATABASENAME VARCHAR(128), BACKUP_TYPE VARCHAR(10) ,LATESTBACKUPDATE DATETIME NULL, HOURS_SINCE_BACKUP  INT, MINUTES_SINCE_BACKUP  INT, BACKUP_SERVER_NAME SYSNAME NULL)

--INSERT ANY DATABASES THAT HAVE NEVER HAD A FULL BACKUP RUN 
INSERT INTO #BACKUP_EXCEPTION(DATABASENAME, BACKUP_TYPE, LATESTBACKUPDATE, HOURS_SINCE_BACKUP, MINUTES_SINCE_BACKUP, BACKUP_SERVER_NAME)
SELECT 
	b.DatabaseName
	,b.BackupType
	,NULL
	,-1
	,-1
	,NULL
	FROM	
	#BackupInfoLast b
	LEFT JOIN #ListenerDBs db on b.DatabaseName  = db.DatabaseName 
WHERE
	db.DatabaseName IS NULL
	AND b.DatabaseName NOT IN(SELECT DatabaseName COLLATE SQL_Latin1_General_CP1_CI_AS FROM dbo.BackupReportExclusion)


--insert any FULLS that are older than the hours parameter @HoursForFull which is passed into the procedure
IF @HoursForFull != 0
BEGIN
	SET @dt = DATEADD(HOUR,@HoursForFull, GETDATE())
	IF @Debug = 1
		SELECT @dt AS 'Full Backup Date'
	INSERT INTO #BACKUP_EXCEPTION(DATABASENAME, BACKUP_TYPE, LATESTBACKUPDATE, HOURS_SINCE_BACKUP, MINUTES_SINCE_BACKUP, BACKUP_SERVER_NAME)
	SELECT 
		b.DatabaseName
		,b.BackupType
		,b.BackupStartDate
		,DATEDIFF(HOUR,b.BackupStartDate, GETDATE())
		,DATEDIFF(MINUTE, b.BackupStartDate, GETDATE())
		,b.ServerName
		FROM	
		#ListenerDBs db
		INNER JOIN #BackupInfoLast b ON db.DatabaseName = b.DatabaseName 
			AND b.BackupType = 'FULL'
			AND b.BackupStartDate < @dt
		LEFT JOIN dbo.BackupReportExclusion bu on b.DatabaseName COLLATE SQL_Latin1_General_CP1_CI_AS = bu.DatabaseName COLLATE SQL_Latin1_General_CP1_CI_AS AND bu.ExcludeFull = 1
	WHERE
		bu.DatabaseName IS NULL

	IF @Debug = 1
	BEGIN
		SELECT '#BACKUP_EXCEPTION (FULL)' AS [TableName], * FROM #BACKUP_EXCEPTION 
	END

END

IF @Debug = 1
		BEGIN
			RAISERROR('',10,1) WITH NOWAIT;
			RAISERROR('Inserting missing DIFF',10,1) WITH NOWAIT;
		END

--insert any DIFFERENTIAL backup that are older than the Minutes parameter @MinutesForDiff which is passed into the procedure
IF @MinutesForDiff != 0
BEGIN
	SET @dt = DATEADD(MINUTE,@MinutesForDiff, GETDATE())
	IF @Debug = 1
		SELECT @dt AS 'Differential Backup Date'
	
	INSERT INTO #BACKUP_EXCEPTION(DATABASENAME, BACKUP_TYPE, LATESTBACKUPDATE, HOURS_SINCE_BACKUP, MINUTES_SINCE_BACKUP,BACKUP_SERVER_NAME)
	SELECT 
		db.DatabaseName
		,'DIFF'
		,b.BackupStartDate
		,CASE WHEN b.BackupStartDate IS NULL THEN -1 ELSE DATEDIFF(HOUR,b.BackupStartDate, GETDATE()) END
		,CASE WHEN b.BackupStartDate IS NULL THEN -1 ELSE DATEDIFF(MINUTE,b.BackupStartDate, GETDATE()) END
		,b.ServerName
		FROM	
		#ListenerDBs db
		INNER JOIN #BackupInfoLast b ON db.DatabaseName COLLATE SQL_Latin1_General_CP1_CI_AS = b.DatabaseName COLLATE SQL_Latin1_General_CP1_CI_AS
			AND b.BackupType = 'DIFF'
			AND b.BackupStartDate < @dt
		LEFT JOIN dbo.BackupReportExclusion bu on db.DatabaseName COLLATE SQL_Latin1_General_CP1_CI_AS = bu.DatabaseName COLLATE SQL_Latin1_General_CP1_CI_AS and bu.ExcludeDiff = 1
		LEFT JOIN #BackupInfoLast  fulls ON db.DatabaseName = fulls.DatabaseName AND fulls.BackupType  = 'FULL' 
	WHERE
		bu.DatabaseName IS NULL
		AND fulls.BackupStartDate < @dt --exclude if a full backup has been taken

	IF @Debug = 1
	BEGIN
		SELECT '#BACKUP_EXCEPTION (DIFF)' AS [TableName], * FROM #BACKUP_EXCEPTION  where BACKUP_TYPE = 'DIFF' ORDER BY DATABASENAME
	END

END

IF @Debug = 1
		BEGIN
			RAISERROR('',10,1) WITH NOWAIT;
			RAISERROR('Inserting missing LOG',10,1) WITH NOWAIT;
		END

--insert any TRANSATION LOGS that are older than the Minutes parameter @MinutesForTranLog which is passed into the procedure
IF @MinutesForTranLog != 0
BEGIN
	SET @dt = DATEADD(MINUTE,@MinutesForTranLog, GETDATE())
	IF @Debug = 1
		SELECT @dt AS 'Tran Log Backup Date'

	INSERT INTO #BACKUP_EXCEPTION(DATABASENAME, BACKUP_TYPE, LATESTBACKUPDATE, HOURS_SINCE_BACKUP, MINUTES_SINCE_BACKUP,BACKUP_SERVER_NAME)
	SELECT 
		db.DatabaseName
		,'Log'
		,b.BackupStartDate
		,ISNULL(DATEDIFF(HOUR,b.BackupStartDate, GETDATE()),-1)
		,ISNULL(DATEDIFF(MINUTE,b.BackupStartDate, GETDATE()),-1)
		,b.ServerName
		FROM	
		#ListenerDBs db
		INNER JOIN sys.databases d on db.DatabaseName COLLATE SQL_Latin1_General_CP1_CI_AS = d.name COLLATE SQL_Latin1_General_CP1_CI_AS 
		INNER JOIN #BackupInfoLast b ON db.DatabaseName = b.DatabaseName
			AND b.BackupType = 'Log'
			AND b.BackupStartDate <  @dt
		LEFT JOIN dbo.BackupReportExclusion bu on db.DatabaseName COLLATE SQL_Latin1_General_CP1_CI_AS = bu.DatabaseName COLLATE SQL_Latin1_General_CP1_CI_AS  AND bu.ExcludeLog =1
	WHERE
		bu.DatabaseName IS NULL
		AND ISNULL(d.recovery_model_desc,'SIMPLE') != 'SIMPLE'

	IF @Debug = 1
	BEGIN
		SELECT '#BACKUP_EXCEPTION (LOG)' AS [TableName], * FROM #BACKUP_EXCEPTION  where BACKUP_TYPE = 'LOG'
	END
END

IF @Debug = 1
		BEGIN
			RAISERROR('',10,1) WITH NOWAIT;
			RAISERROR('All missing inserted',10,1) WITH NOWAIT;
		END

IF @Debug = 1
BEGIN
	SELECT
		'#BACKUP_EXCEPTION ' AS Table_BACKUP_EXCEPTION 
		,DATABASENAME AS 'Database Name'
		,BACKUP_TYPE AS 'Backup Type'
		,LATESTBACKUPDATE AS 'Last Backup Date'
		,CASE WHEN BACKUP_TYPE= 'FULL' THEN HOURS_SINCE_BACKUP ELSE NULL END AS 'Hours Since Backup'
		,CASE WHEN BACKUP_TYPE= 'FULL' THEN  @HoursForFull * -1 ELSE NULL END AS 'Full Frequency'
		,CASE WHEN BACKUP_TYPE ='LOG' THEN MINUTES_SINCE_BACKUP ELSE NULL END 'Minutes Since Backup'
		,CASE WHEN BACKUP_TYPE= 'LOG' THEN @MinutesForTranLog * -1 ELSE NULL END AS 'Log Frequency'
		,BACKUP_SERVER_NAME AS 'Last Backup Server Name'
		FROM
		#BACKUP_EXCEPTION 
	ORDER BY
		BACKUP_TYPE
		,DATABASENAME
		,MINUTES_SINCE_BACKUP
END


/********************************************************************************************************************************
		Build the parameter list table and the exclustions table
		They will be emailed regardless of whether or not issues are found
********************************************************************************************************************************/
SELECT @ReportDate = CONVERT(VARCHAR(30), GETDATE(),100)
SET @HtmlParams = '<table border = 1>     
		<tr> <th>Parameter Name      </th> <th> Parameter Value             </th></tr>'        
		+ '<td align ="left">@NamesList </td> <td align ="left">' + @NamesList + '</tr>' 
		+ '<TR><td align ="left">@InstanceNames </td> <td align ="left">' + @InstanceNames + '</tr>' 
		+ '<TR><td align ="left">@HoursForFull </td> <td align ="left">' + CAST(@HoursForFull AS VARCHAR(30))+ '</tr>' 
		+ '<TR><td align ="left">@MinutesForDiff </td> <td align ="left">' + CAST(@MinutesForDiff  AS VARCHAR(30))+ '</tr>' 
		+ '<TR><td align ="left">@MinutesForTranLog </td> <td align ="left">' + CAST(@MinutesForTranLog  AS VARCHAR(30))+ '</tr>' 
		+ '<TR><td align ="left">Report Creation Time </td> <td align ="left">' + @ReportDate + '</tr></table>'


SET @HtmlExclusions = '<BR><table border = 1>     
		<tr><th>Database Exclusions      </th> <th>Exclude Full</th> <th>Exclude Diff</th> <th>Exclude Log</th>					</tr>'    
SELECT 
	@HtmlExclusions = @HtmlExclusions + '<tr>'
	+'<td align ="left">' + DatabaseName + '</td>' 
	+'<td align ="middle">' + CAST(ExcludeFull AS VARCHAR(10)) + '</td>' 
	+'<td align ="center">' + CAST(ExcludeDiff AS VARCHAR(10)) + '</td>' 
	+'<td align ="center">' + CAST(ExcludeLog AS VARCHAR(10)) + '</td></tr>' 
 FROM 
	dbo.BackupReportExclusion 
ORDER BY 
	DatabaseName

SET @HtmlExclusions =  @HtmlExclusions +'</table>'
IF @Debug = 1
BEGIN
	SELECT @HtmlParams AS '@HtmlParams'
	SELECT @HtmlExclusions AS '@HtmlExclusions'
END
/********************************************************************************************************************************/

IF EXISTS ( SELECT TOP 1 1 FROM #BACKUP_EXCEPTION )    
BEGIN    
		SET @Xml = CAST(( SELECT [DATABASENAME] AS 'td','',[BACKUP_TYPE] AS 'td','',CASE WHEN [LATESTBACKUPDATE] IS NULL THEN 'null' ELSE   CONVERT(VARCHAR(30),[LATESTBACKUPDATE],100) END AS 'td' ,'',[HOURS_SINCE_BACKUP] AS 'td'  ,'',[MINUTES_SINCE_BACKUP] AS 'td'    ,'',ISNULL([BACKUP_SERVER_NAME],' ') AS 'td'      
						FROM  [#BACKUP_EXCEPTION]     
						FOR XML PATH('tr'), ELEMENTS ) AS NVARCHAR(MAX))    
    
		SET @Body ='<html><body><H2>Native BackUp Exception Report:   </H2>    
		<H3>' +@H3Text+ '</H3>    
		<H4>The following backups needs to be checked to ensure that backup is current:  </H4>    
	<BR>'        
	
	SET  @Body = @Body +  @HtmlParams 
	 
	SET @Body = @Body +   '</tbody></table><BR>' 
	
	
	
	SET @Body = @Body + ' <table border = 1>     
		<tr> <th> DATABASENAME      </th> <th> BACKUP TYPE                 </th>  <th> LATEST BACKUP DATE                 </th>  <th> HOURS WITHOUT BACKUP                 </th>  <th> MINUTES WITHOUT BACKUP                 </th>  <th> LATEST BACKUP SERVER NAME                 </th> </tr>'        
    
		SET @Body = @Body + @Xml + '</table>' + @HtmlExclusions + '</body></html>'     
    
    
   
    
		EXEC msdb.dbo.sp_send_dbmail     
		@recipients=@EmailRecipients,         
		@subject = @EmailSubject,    
		@body =@Body,    
		@body_format ='HTML',    
		@query_result_header = 0,    
		@exclude_query_output = 1,    
		@append_query_error = 1,    
		@query_result_no_padding = 1,    
		@profile_name = @EmailProfile;    
  
	--Wrapping this in a try catch as I do not want this procedure to error out, but I do want the notification written to the SQL Error Log.
	BEGIN TRY
		SET @msg = 'Procedure FDDBA..' + OBJECT_NAME(@@PROCID) +', was run on server ' + @@SERVERNAME + ', backup exceptions found and were emailed.'
		RAISERROR(@msg,10,1) WITH NOWAIT;
		IF @WriteToErrorLog =1
			RAISERROR(@msg,16,1) WITH LOG;
	END TRY
	BEGIN CATCH -- do nothing, but have to do something
		PRINT ''
	END CATCH
END    
ELSE
BEGIN
	BEGIN TRY
		SET @msg = 'Procedure FDDBA..' + OBJECT_NAME(@@PROCID) +', No Backup exceptions found. This is an informational message only, no user action is required.'
		RAISERROR(@msg, 10,1) WITH NOWAIT;
		IF @WriteToErrorLog =1
			RAISERROR(@msg, 16,1) WITH LOG;
	END TRY
	BEGIN CATCH
		PRINT ''
	END CATCH

	SET @Body ='<html><body><H2>Native BackUp Exception Report:  NO ISSUES FOUND </H2>  '
	+ @HtmlParams + @HtmlExclusions +  '</body></html>'  

	IF ISNULL(@OnCleanRecipients,'') != ''
	BEGIN
		EXEC msdb.dbo.sp_send_dbmail     
				@recipients= @OnCleanRecipients,         
				@subject = @EmailSubject,    
				@body =@Body,    
				@body_format ='HTML', 
				@profile_name = @EmailProfile;
	END
END
GO
